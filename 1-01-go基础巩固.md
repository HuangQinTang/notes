### int

- int大小跟随系统字长，64位就是8字节，32位就是4字节。指针大小也是系统字长。

### 字符串

- 底层结构定义在string.go文件下，stringStruct结构体

  ![image-20230122162131163](.\img\image-20230122162131163.png)

  字符串本质是一个结构体，字段str是一个指针，指向byte数组，字段len表示byte数组长度。字符串采用utf8编码，一个utf8字符作为底层byte数组的一个元素。

- 数字转字符串姿势

  ```go
  //使用string()将数字转字符串时，结果是会是该数组所代表的ascii字符
  fmt.Println(string(97))		//a，不会打印"97"
  
  //正确做法应该是使用strconv.Itoa()函数
  fmt.Println(strconv.Itoa(97))
  //或者用fmt.Sprintf()，通常这种做法语义性更强，但效率没有前者高
  fmt.Println(fmt.Sprintf("%c", 97))
  ```

- 遍历字符串

  ```go
  str := "我abc123"
  for i := 0; i < len(str); i++ {
  	fmt.Printf("%d %c\n", i, str[i])
  }
  //得到以下输出 
  //0 æ
  //1 
  //2 
  //3 a
  //4 b
  //5 c
  //6 1
  //7 2
  //8 3
  ```

  - 字符串底层是一个byte(字节)数组，Go 语言里的字符串的内部实现使用utf-8编码(变长)，一个字符占用1到4字节，中文通常占3个byte(字节)，所以遍历字符串(遍历byte数组)，遍历到中文"我"（前三个字节），就乱码了。英文和数字在utf8中则占一个字节，不会乱码。

  - 可以将字符串转换为rune数组(byte数组转rune数组)。rune，3字节，中文在utf8刚好也3字节。

    ```go
    str := "我abc123"
    for i := 0; i < len([]rune(str)); i++ {
    	fmt.Printf("%d %c\n", i, []rune(str)[i])
    }
    //正常展示
    //0 我
    //1 a
    //2 b
    //3 c
    //4 1
    //5 2
    //6 3
    ```

  - rune类型3字节，代表一个 utf-8字符(不一定，有的utf8四字节)。byte 型，代表了ASCII码的一个字符。

    ```go
    str := "我abc123"
    fmt.Println([]byte(str))   //[230 136 145 97 98 99 49 50 51]
    fmt.Println([]rune(str))   //[25105 97 98 99 49 50 51]
    fmt.Printf("%c", 25105)	   //我
    ```

  - 或者使用range，range循环在遍历字符串的过程中，会对字符串进行 utf-8 解码

    ```go
    str := "我abc123"
    for k, v := range str {
    	fmt.Printf("%d %c\n", k, v)
    }
    //结果如下
    //0 我
    //3 a
    //4 b
    //5 c
    //6 1
    //7 2
    //8 3
    ```

- 切分字符串

  字符串是不可变的，要修改他，得转换为[]byte()或[]rune，通过下标索引修改

  `s = string([]rune(s)[:3])`

- 字符串累加可以使用`strings.Join()`、`bytes.Buffer`结构体的`WriteString()`方法

### 切片

- 底层结构定义在slice.go下slice结构体，字段array指向底层数组，len底层数组的长度，cap容量。

  ![image-20230122164526549](.\img\image-20230122164526549.png)

  append向切片追加1个元素时，如果len+1小于cap，只调整len(编译器负责)。如果需要扩容则调用runtime.growslice()。该方法会创建一个新的底层数组，将array指向新的底层数组，并拷贝旧值。切片扩容时，并发不安全。切片并发要加锁。

  - 扩容机制很复杂，与**与CPU位数、元素大小、是否包含指针、追加个数**等都有关系。
  - 通常需要的容量 `cap` 超过原切片容量的两倍 `doublecap`，会直接使用需要的容量作为新容量`newcap`。否则，当原切片长度小于1024时，新切片的容量会直接翻倍。而当原切片的容量大于等于1024时，会反复地增加25%，直到新容量超过所需要的容量。
  - 随着语言的演化，这种增长算法可能会有所改变。

### 结构体

- 空结构体，有地址无长度，不占用内存。所有的空结构体都指向malloc.go下的zerobase变量。用于节省内存，比如map的value是struct{}，chan的value是struct{}。

  ![image-20230122155855042](.\img\image-20230122155855042.png)

- 结构体构造函数可变入参（其实就是适配器模式）

  ```go
  type User struct {
  	Id   int
  	Name string
  	Age  int
  }
  
  type SetUserFunc func(*User)
  
  func NewUser(funs ...SetUserFunc) *User {
  	u := new(User)
  	for _, f := range funs {
  		f(u)
  	}
  	return u
  }
  
  func SetUserId(id int) SetUserFunc {
  	return func(u *User) {
  		u.Id = id
  	}
  }
  
  func SetUserName(name string) SetUserFunc {
  	return func(u *User) {
  		u.Name = name
  	}
  }
  
  func main() {
  	u := NewUser(
  		SetUserId(10),
  		SetUserName("小明"),
  	)
  	fmt.Println(u)
  }
  ```

### map

- 底层数据结构定义在map.go下的hmap结构体。拉链法实现。make的初始化可以关注map.go/makemap()方法。

- 关键字段是buckets，指向一个bmap数组，bmap结构体的tophash是key hash后值前一个字节(高8位)，一个bmap可以存放8个kv，因为map可以存放不同数据结构，keys，elems,overflow类型在编译才确定。overflow指向溢出桶。

  ![image-20230122173423596](.\img\image-20230122173423596.png)

- 当bmap存不下kv时，会通过extra.nextOverflow查看下个可用的溢出桶地址，然后将overflow指向该溢出桶。

  ![image-20230122175457486](.\img\image-20230122175457486.png)

- 桶号的计算，hmap的hash0字段存放hash种子，将key用该种子hash计算后得到一窜hash值，hmap的B字段是当前桶的对数，比如是3，那么就去该hash值后三位数字，010，二进制2，表示该key应存放在2号桶。

![image-20230122181009347](.\img\image-20230122181009347.png)

- hash值的高8位存放在bmap的tophash数组中。

  ![image-20230122182405963](.\img\image-20230122182405963.png)

- 查找是根据上面的步骤找到桶，根据key哈希值的高八位从tophash获取元素下标，找从keys数组判断是否是该keys如果不是，判断下tophash是否还要相同高八位，没有就看看有没有溢出桶。

  ![image-20230122182623432](.\img\image-20230122182623432.png)

- 写入和查找过程差不多，找到桶，看看有无tophash，有判断key是否是自己 的key，是覆盖。不是往下找，直到溢出桶也无，则填充tophash以及对应的keys,elems。

- 扩容

  触发条件：（1）装载因子超过6.5（平均每个槽6.5个key）。（2）使用了太多溢出桶（溢出桶超过了普通桶）。

  扩容类型：（1）等量扩容：数据不多但溢出桶太多了（整理）。（2）翻倍扩容：数据太多了。

- 扩容步骤

  （1）创建一组新桶，oldbuckets指向原有数据桶，buckets指向新数据桶，map标记为扩容状态。

  （2）渐进式将旧桶数据迁移到新桶，即操作一个旧桶时，将旧桶数据迁移到新桶（读取时不进行迁移，只根据tophash判断读取新桶还是旧桶）。tophash不只表示key的哈希值的高8位，当tophash对应的K/V未被使用时，存的是K/V对应位置的状态。

  （3）数据迁移完成后，oldbuckets回收。

- map扩容会有并发问题，此时可以用sync.map，适合读多写少。他封装了2个map，read map 和 dirty map，分离了扩容问题，当对map查、改时（不会触发扩容），使用read map。当进行新增（会触发扩容）使用dirty map。

### 接口

- 接口值底层定义在runtime2.go下iface结构体

  ```go
  type iface struct {
  	tab  *itab
  	data unsafe.Pointer
  }
  ```

  data记录数据的地址

  tab记录接口的类型信息和实现的方法

- 空接口

  ```golang
  type eface struct {
  	_type *_type
  	data  unsafe.Pointer
  }
  ```

  空接口和接口在底层不是同一个数据结构，他只定义了类型和数据，可以承载任何数据。

- ```go
  type Person interface {
  	Say()
  }
  
  type LaoWang struct {
  	name string
  }
  
  func (w LaoWang) Say() {
  	fmt.Println(w.name)
  }
  
  func main() {
  	var p Person = &LaoWang{}
  	fmt.Println(p)
  }
  ```

  LaoWang的Say方法即使接收者是值对象也能实现Person接口，是因为在编译时，go默认帮LaoWang实现

  ```golang
  func (w *LaoWang) Say() {
  	fmt.Println(w.name)
  }
  ```

### nil

- 在底层是一个变量，表示指针，channel，fun，interface，map，slice的零值，在编译时确定

  ```go
  // nil is a predeclared identifier representing the zero value for a
  // pointer, channel, func, interface, map, or slice type.
  var nil Type // Type must be a pointer, channel, func, interface, map, or slice type
  ```

  空接口零值是nil，一旦有了类型信息就不是nil。


### Context

- 子context可以读取父context设置在上下文中的值，但父context无法读取子context设置的值
- 但如果父context往上下文存放一个map，子context修改该map，此时父类可以读到子context设置在map中的值，但不建议这样做，不安全。context意指不可变安全的传递上下文。
- 子context无法重置父context设置的超时时间。比如父context设置了5秒超时，此时子context想重置超时时间，无效。
- 不建议把context嵌入在结构体中，除非该结构体也是伴随整个请求声明周期。
- 所有公共方法(调用第三方服务，提供服务)，第一个参数用context

### Sync包

#### Mutex && RWMutex

- 一般用法是将Mutex或者RWMutex和需要被保护的资源(会被多个goroutine同时访问操作)封装在一个结构体，只读不需要保护，优先使用RWMutex。

- 一个goroutine不可用同时加读锁和写锁，这样会造成死锁。

- 任何非线程安全的类型、接口都可以利用读写锁+装饰器模式无侵入地改造为线程安全的类型、接口。

- RWMutex是写优先，即加了写锁，就会阻塞后续的读锁。有的语言读写锁的设计是读优先，即加了读锁，另个线程加写锁，如果此时又有一个线程要加读锁，这个线程会优先加写锁的线程拿到锁。

- **抢锁步骤**

  1. 先上来一个CAS操作，如果这把锁正空闲，并且没人抢，那么就直接成功。

  2. 否则，自旋几次，如果这个时候成功了，也不用加入队列。

  3. 否则，加入队列。

  4. 从队列中被唤醒

     (1)正常模式：和新来的一起枪锁，但大概率失败

     (2)饥饿模式：肯定拿到锁

     当队列中只剩1个goroutine或者队列头等待时间小于1ms，退出饥饿模式。队列中的goroutine再次与新来的竞争锁。

- 注意事项

  1. 写多读少可以直接加锁

     ```go
     func (s *this) Check() {
         s.mutex.Lock()
         //检查数据
         //执行逻辑
         s.mutex.Unlock()
     }
     ```

  2. 读多写少建议这样写

     ```go
     func (s *this) Check() {
         s.mutex.Lock()
         //检查数据，是否能继续往下走
         s.mutex.Unlock()
         
         //数据没问题加写锁，第一个检测可以避免上来就写锁阻塞其他线程操作
         s.mutex.Lock()
         //第二次检查，如果没问题
      	//执行逻辑
         defer s.mutex.Unlock()
     }
     ```

  3. Mutex和RWMutex的写锁都是不可重入的，注意递归使用的时候别重入了

  4. 尽可能用defer来解锁，即使panic中断，defer也能执行，确保释放掉锁。
  
  4. 可以通过`go vet main.go`查看是否有拷贝锁的情况。（拷贝锁容易出现重复加锁panic）

#### Once

- 确保只能执行一次，如果结构体嵌入Once，记得使用指针接收者，值接收者会发生拷贝导致Once失效

- 核心源码

  ```go
  type Once struct {
      done uint32		//值为1表示执行过
      m Mutex			//锁
  }
  
  func (o *Once) Do(f func()) {
      //原子判断是否执行过
      if atomic.LoadUint32(&o.done) == 0 {
          //没有尝试执行
          o.doSlow(f)
      }
  }
  
  func (o *Once) doSlow(f func()) {
      //现在才加锁
      o.m.Lock()
      defer o.m.UnLock()
      //避免多个线程同时执行到这，再次判断是否执行过
      if o.done == 0 {
          //执行f(),defer修改执行状态
          defer atomic.StoreUin32(&o.done, 1)
          f()
      }
  }
  ```

  没有直接利用读写锁，而是利用原子操作来扮演读锁的角色。

#### Pool

一般情况下，如果要考虑缓存资源，比如创建好的对象(高频、生命周期短)，那么可以使用**sync.Pool**

- sync.Pool会先查看自己是否有资源，**有则直接返回**
- 没有则**创建一个新的**
- sync.Pool会在GC的时候**释放缓存的资源**

一般用sync.Pool都是为了复用内存：

- 它**减少了内存分配**，也减轻了GC压力(最终主要)
- **少消耗CPU资源**(内存分类和GC都是CPU密集操作)

**大概实现**

​	每个p都会维护一个本地的poolLocal对象。每个poolLocal有一个**private**和**shared**，shared指向的是一个全p能访问的**poolChain**。poolChain是一个链表+ring buffer的双重结构。此外每个p还维护一个victim，用以存放经过一次gc的poolLocal。

​	poolLocal需要两轮gc才真正释放，gc时会先清空victim然后把poolLocal拷贝到victim，最后再清空poolLocal。也就是第一轮gc poolLocal不会回收，会被赋值到victim，第二轮gc，才会把poolLocal从victim清空。

​	**get步骤**

1. 先从private获取

2. 拿不到，尝试从shared拿

3. 拿不到，尝试偷别的p的shared

4. 拿不到，从victim(缓刑)拿经过一次gc的对象

5. 最后拿不到则创建

   为什么最后才去找victim，偷不是一个全局竞争的过程么？显然先找victim会有更好的性能。

   因为sync.Pool希望victim里面的对象尽可能被回收掉。

​	**put步骤**

1. 直接放本地p的poolLocal中的private

2. 已有则存放在shared指向的poolChain。

   如果poolChain链表的头节点不存在，则创建一个容量为8的ring buffer，把数据丢进ring buffer作为头节点

   如果poolChain链表的头节点所指向的ring buffer未满，存放进去

   已满，创建一个新节点，创建一个2倍容量的ring buffer存放数据，新节点指向新的ring buffer。

**使用思考**

1. 如果一个buffer占据了大量内存，要不要放回去？

2. 怎么控制整个池的内存使用量？因为依托于GC是比较不可控的

   怎么控制单个Buffer内存上限？

   怎么控制Buffer数量？

   怎么控制总体内存？

可以简单封装put操作，put元素进去时用unsafe判断元素内存大小，太大不放

**面试热点**

- sync.Pool和GC的关系：数据默认在local里面，GC的时候会被挪到victim里，如果这时候有P用了victim的数据，数据会重新回到Local中

- poolChain的设计：核心在于理解poolChain是一个双向链表加ring buffer的双重结构

- 由这两个核心衍生出来的各种问题

  - 什么时候P会用 victim的数据:偷都偷不到的时候。

  - 为什么G0会设计这种结构?一个全局共享队列不好吗?

    这个问题要结合TLB来回答,TLB解決全局锁竞争的方案,Go结合自身P这么一个优势,设计出来的。
    
  - 窃取:这个可以作为一个刷亮点的东西,结合GMP调度里面的工作窃取,原理都是一样的。

  - 使用sync.Pool有什么注意点(缺点、优点)?

    高版本的Go里面的sync.Poo没特别大的缺点,硬要说就是内存使用量不可控,以及GC之后即便可以用 victim,Get的速率还是要差点。

#### WaitGroup

用于同步多个goroutine之间工作的

**实现细节**

- noCopy，sync很多结构体都嵌入了这样一个值，他会告诉编译器，该结构体不允许复制，比如使用值接收者时会发生值拷贝。

  ```go
  type noCopy struct{}
  type WaitGroup struct {
      noCopy noCopy
      //state1:在64位下,高32位记录了还有多少任务在运行;低32位记录了有多少 goroutine在等Wat()方法返回
      state1 uint64
      //state2:信号量,用于挂起或者唤醒goroutine,约等于 Mutex里面的sema字段(要注意横向对比)
      state2 uint64
  }
  ```

- 根据这两个字段我们可以进一步猜测 Waitgroup的实现细节:

  Add:看上去就是 state1的高32位自增1,原子操作一把梭

  Done:看上去就是 state1的高32位自减1,原子操作一把梭,然后看看是不是要唤醒等待 goroutine

  Wait:看上去就是 state1的低32位自增1,同时利用 state2和 runtime Semacquire调用把当前 goroutine挂起其实Done就相当于Add(-1)

#### channel

如果 channel使用不当,就会导致 goroutine泄露(一直阻塞在那占着内存不干活)，被阻塞后无人唤醒

- 三种情况

  只发送不接收,那么发送者一直阻塞,会导致发送者 goroutine泄露

  只接收不发送,那么接收者一直阻塞,会导致接收者 goroutine泄露

  读写ni都会导致 goroutine泄露

注意事项：如果用channel发送指针，必然发生逃逸。

channel发送的步骤，（1）阻塞队列存在等待接收数据的协程，直接将数据拷贝给该协程（2）没有接收协程那么放入环形缓存（3）没有接收人，没有缓存，将自己包装进入等待发送队列，休眠等待被唤醒（当被唤醒那一刻已发送数据）。

channel接收步骤，（1）等待发送队列有g且没有缓存数据，拷贝发送等待队列g的数据，然后唤醒它（2）缓存有数据，等待发送队列也有g，从缓存取走一个数据，将等待发送队列的g数据拷贝进缓存，然后唤醒它。（3）没有g在休眠等待发送，但缓存有内容，直接从缓存取走数据（4）发送等待队列没有要发送的g，缓存也没有输，则阻塞自己等待唤醒。当被唤醒那一刻以收到数据（我叫醒你一定已经发送了数据）

面试要点：

1. channel有 buffer 和没有 buffer 有什么特点？（无buffer读写阻塞）
2. 发送数据到 nil channel 会怎样? 从 nil channel 接收数据会怎样? （阻塞无法被唤醒）
3. 发送到已关闭的 channel 会怎样?（死锁）
4. 从已关闭的 channel 接收数据会怎样?（返回类型零值）
5. channel是怎么引起 goroutine 泄露的? 或者说，goroutine 泄露有什么原因?（channel一直阻塞，无法被唤醒）
6. channel发送步骤，channel 接收步骤？
7. 为什么 channel发送指针数据会引起内存泄露?（只发送不接收，只接受不发生，一直阻塞）
8. 可能的代码题:
   用channel实现一个任务池
   用channel 来控制 goroutine 数量
   用channe[来实现生产者-消费者模型

### 反射

runtime+unsafe实现

reflect.Value: 用于操作值，部分值是可以被反射修改的

reflect.Type: 用于操作类信息，类信息是只能读取

reflect.Type 可以通过 reflect.Value 得到，但是反过来则不行。

### unsafe

uintptr和unsafe.Pointer的区别：前者代表的是一个具体的地址，后者代表的是一个逻辑上的指针。后者在GC等情况下，go runtime会帮你调整，使其永远指向真实存放对象的地址。

Go对象是怎么对齐的？按照字长。

怎么计算对象地址？对象的起始地址是通过反射获取，对象内部的地址是通过起始地址+字段偏移量来计算。

unsafe为什么比反射高效？可以简单认为反射帮我们封装来很多unsafe的操作，所以直接使用unsafe绕开来这种封装开销。
