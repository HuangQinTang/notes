### 字符串

- 数字转字符串姿势

  ```go
  //使用string()将数字转字符串时，结果是会是该数组所代表的ascii字符
  fmt.Println(string(97))		//a，不会打印"97"
  
  //正确做法应该是使用strconv.Itoa()函数
  fmt.Println(strconv.Itoa(97))
  //或者用fmt.Sprintf()，通常这种做法语义性更强，但效率没有前者高
  fmt.Println(fmt.Sprintf("%c", 97))
  ```

- 遍历字符串

  ```go
  str := "我abc123"
  for i := 0; i < len(str); i++ {
  	fmt.Printf("%d %c\n", i, str[i])
  }
  //得到以下输出
  //0 æ
  //1 
  //2 
  //3 a
  //4 b
  //5 c
  //6 1
  //7 2
  //8 3
  ```

  - 字符串底层是一个byte(字节)数组，Go 语言里的字符串的内部实现使用utf-8编码(变长)，一个字符占用1到4字节，中文通常占3个byte(字节)，所以遍历字符串(遍历byte数组)，遍历到中文"我"（前三个字节），就乱码了。英文和数字在utf8中则占一个字节，不会乱码。

  - 可以将字符串转换为rune数组(byte数组转rune数组)。rune，3字节，中文在utf8刚好也3字节。

    ```go
    str := "我abc123"
    for i := 0; i < len([]rune(str)); i++ {
    	fmt.Printf("%d %c\n", i, []rune(str)[i])
    }
    //正常展示
    //0 我
    //1 a
    //2 b
    //3 c
    //4 1
    //5 2
    //6 3
    ```

  - rune类型3字节，代表一个 utf-8字符(不一定，有的utf8四字节)。byte 型，代表了ASCII码的一个字符。

    ```go
    str := "我abc123"
    fmt.Println([]byte(str))   //[230 136 145 97 98 99 49 50 51]
    fmt.Println([]rune(str))   //[25105 97 98 99 49 50 51]
    fmt.Printf("%c", 25105)	   //我
    ```

  - 或者使用range，range循环在遍历字符串的过程中，会对字符串进行 utf-8 解码

    ```go
    str := "我abc123"
    for k, v := range str {
    	fmt.Printf("%d %c\n", k, v)
    }
    //结果如下
    //0 我
    //3 a
    //4 b
    //5 c
    //6 1
    //7 2
    //8 3
    ```

- 字符串是不可变的，要修改他，得转换为[]byte()或[]rune，通过下标索引修改

- 字符串累加可以使用`strings.Join()`、`bytes.Buffer`结构体的`WriteString()`方法

### 结构体

- 结构体构造函数可变入参（其实就是适配器模式）

  ```go
  type User struct {
  	Id   int
  	Name string
  	Age  int
  }
  
  type SetUserFunc func(*User)
  
  func NewUser(funs ...SetUserFunc) *User {
  	u := new(User)
  	for _, f := range funs {
  		f(u)
  	}
  	return u
  }
  
  func SetUserId(id int) SetUserFunc {
  	return func(u *User) {
  		u.Id = id
  	}
  }
  
  func SetUserName(name string) SetUserFunc {
  	return func(u *User) {
  		u.Name = name
  	}
  }
  
  func main() {
  	u := NewUser(
  		SetUserId(10),
  		SetUserName("小明"),
  	)
  	fmt.Println(u)
  }
  ```



### 引用类型

- map、chan、slice作函数入参无需声明指针，因为他们是引用类型，拷贝的是所指向内存的内存地址值。

### Context

- 子context可以读取父context设置在上下文中的值，但父context无法读取子context设置的值
- 但如果父context往上下文存放一个map，子context修改该map，此时父类可以读到子context设置在map中的值，但不建议这样做，不安全。context意指不可变安全的传递上下文。
- 子context无法重置父context设置的超时时间。比如父context设置了5秒超时，此时子context想重置超时时间，无效。
- 不建议把context嵌入在结构体中，除非该结构体也是伴随整个请求声明周期。
- 所有公共方法(调用第三方服务，提供服务)，第一个参数用context

### Sync包

#### Mutex && RWMutex

- 一般用法是将Mutex或者RWMutex和需要被保护的资源(会被多个goroutine同时访问操作)封装在一个结构体，只读不需要保护，优先使用RWMutex。

- 一个goroutine不可用同时加读锁和写锁，这样会造成死锁。

- 任何非线程安全的类型、接口都可以利用读写锁+装饰器模式无侵入地改造为线程安全的类型、接口。

- RWMutex是写优先，即加了写锁，就会阻塞后续的读锁。有的语言读写锁的设计是读优先，即加了读锁，另个线程加写锁，如果此时又有一个线程要加读锁，这个线程会优先加写锁的线程拿到锁。

- **抢锁步骤**

  1. 先上来一个CAS操作，如果这把锁正空闲，并且没人抢，那么就直接成功。

  2. 否则，自旋几次，如果这个时候成功了，也不用加入队列。

  3. 否则，加入队列。

  4. 从队列中被唤醒

     (1)正常模式：和新来的一起枪锁，但大概率失败

     (2)饥饿模式：肯定拿到锁

     当队列中只剩1个goroutine或者队列头等待时间小于1ms，退出饥饿模式。队列中的goroutine再次与新来的竞争锁。

- 注意事项

  1. 写多读少可以直接加锁

     ```go
     func (s *this) Check() {
         s.mutex.Lock()
         //检查数据
         //执行逻辑
         s.mutex.Unlock()
     }
     ```

  2. 读多写少建议这样写

     ```go
     func (s *this) Check() {
         s.mutex.Lock()
         //检查数据，是否能继续往下走
         s.mutex.Unlock()
         
         //数据没问题加写锁，第一个检测可以避免上来就写锁阻塞其他线程操作
         s.mutex.Lock()
         //第二次检查，如果没问题
      	//执行逻辑
         defer s.mutex.Unlock()
     }
     ```

  3. Mutex和RWMutex的写锁都是不可重入的，注意递归使用的时候别重入了

  4. 尽可能用defer来解锁，即使panic中断，defer也能执行，确保释放掉锁。

#### Once

- 确保只能执行一次，如果结构体嵌入Once，记得使用指针接收者，值接收者会发生拷贝导致Once失效

- 核心源码

  ```go
  type Once struct {
      done uint32		//值为1表示执行过
      m Mutex			//锁
  }
  
  func (o *Once) Do(f func()) {
      //原子判断是否执行过
      if atomic.LoadUint32(&o.done) == 0 {
          //没有尝试执行
          o.doSlow(f)
      }
  }
  
  func (o *Once) doSlow(f func()) {
      //现在才加锁
      o.m.Lock()
      defer o.m.UnLock()
      //避免多个线程同时执行到这，再次判断是否执行过
      if o.done == 0 {
          //执行f(),defer修改执行状态
          defer atomic.StoreUin32(&o.done, 1)
          f()
      }
  }
  ```

  没有直接利用读写锁，而是利用原子操作来扮演读锁的角色。

#### Pool

一般情况下，如果要考虑缓存资源，比如创建好的对象(高频、生命周期短)，那么可以使用**sync.Pool**

- sync.Pool会先查看自己是否有资源，**有则直接返回**
- 没有则**创建一个新的**
- sync.Pool会在GC的时候**释放缓存的资源**

一般用sync.Pool都是为了复用内存：

- 它**减少了内存分配**，也减轻了GC压力(最终主要)
- **少消耗CPU资源**(内存分类和GC都是CPU密集操作)

**大概实现**

​	每个p都会维护一个本地的poolLocal对象。每个poolLocal有一个**private**和**shared**，shared指向的是一个全p能访问的**poolChain**。poolChain是一个链表+ring buffer的双重结构。此外每个p还维护一个victim，用以存放经过一次gc的poolLocal。

​	poolLocal需要两轮gc才真正释放，gc时会先清空victim然后把poolLocal拷贝到victim，最后再清空poolLocal。也就是第一轮gc poolLocal不会回收，会被赋值到victim，第二轮gc，才会把poolLocal从victim清空。

​	**get步骤**

1. 先从private获取

2. 拿不到，尝试从shared拿

3. 拿不到，尝试偷别的p的shared

4. 拿不到，从victim(缓刑)拿经过一次gc的对象

5. 最后拿不到则创建

   为什么最后才去找victim，偷不是一个全局竞争的过程么？显然先找victim会有更好的性能。

   因为sync.Pool希望victim里面的对象尽可能被回收掉。

​	**put步骤**

1. 直接放本地p的poolLocal中的private

2. 已有则存放在shared指向的poolChain。

   如果poolChain链表的头节点不存在，则创建一个容量为8的ring buffer，把数据丢进ring buffer作为头节点

   如果poolChain链表的头节点所指向的ring buffer未满，存放进去

   已满，创建一个新节点，创建一个2倍容量的ring buffer存放数据，新节点指向新的ring buffer。

**使用思考**

1. 如果一个buffer占据了大量内存，要不要放回去？

2. 怎么控制整个池的内存使用量？因为依托于GC是比较不可控的

   怎么控制单个Buffer内存上限？

   怎么控制Buffer数量？

   怎么控制总体内存？

可以简单封装put操作，put元素进去时用unsafe判断元素内存大小，太大不放

**面试热点**

- sync.Pool和GC的关系：数据默认在local里面，GC的时候会被挪到victim里，如果这时候有P用了victim的数据，数据会重新回到Local中

- poolChain的设计：核心在于理解poolChain是一个双向链表加ring buffer的双重结构

- 由这两个核心衍生出来的各种问题

  - 什么时候P会用 victim的数据:偷都偷不到的时候。

  - 为什么G0会设计这种结构?一个全局共享队列不好吗?

    这个问题要结合TLB来回答,TLB解決全局锁竞争的方案,Go结合自身P这么一个优势,设计出来的。
    
  - 窃取:这个可以作为一个刷亮点的东西,结合GMP调度里面的工作窃取,原理都是一样的。

  - 使用sync.Pool有什么注意点(缺点、优点)?

    高版本的Go里面的sync.Poo没特别大的缺点,硬要说就是内存使用量不可控,以及GC之后即便可以用 victim,Get的速率还是要差点。

#### WaitGroup

用于同步多个goroutine之间工作的

**实现细节**

- noCopy，sync很多结构体都嵌入了这样一个值，他会告诉编译器，该结构体不允许复制，比如使用值接收者时会发生值拷贝。

  ```go
  type noCopy struct{}
  type WaitGroup struct {
      noCopy noCopy
      //state1:在64位下,高32位记录了还有多少任务在运行;低32位记录了有多少 goroutine在等Wat()方法返回
      state1 uint64
      //state2:信号量,用于挂起或者唤醒goroutine,约等于 Mutex里面的sema字段(要注意横向对比)
      state2 uint64
  }
  ```

- 根据这两个字段我们可以进一步猜测 Waitgroup的实现细节:

  Add:看上去就是 state1的高32位自增1,原子操作一把梭

  Done:看上去就是 state1的高32位自减1,原子操作一把梭,然后看看是不是要唤醒等待 goroutine

  Wait:看上去就是 state1的低32位自增1,同时利用 state2和 runtime Semacquire调用把当前 goroutine挂起其实Done就相当于Add(-1)

#### channel

如果 channel使用不当,就会导致 goroutine泄露(一直阻塞在那占着内存不干活)，被阻塞后无人唤醒

- 三种情况

  只发送不接收,那么发送者一直阻塞,会导致发送者 goroutine泄露

  只接收不发送,那么接收者一直阻塞,会导致接收者 goroutine泄露

  读写ni都会导致 goroutine泄露

注意事项：如果用channel发送指针，必然发生逃逸。

channel接收步骤，先看对面有没有人，再看有无缓冲，都无则阻塞自己等待唤醒。当被唤醒那一刻以收到数据（我叫醒你一定已经发送了数据）

面试要点：

1. channel有 buffer 和没有 buffer 有什么特点？（无buffer读写阻塞）
2. 发送数据到 nil channel 会怎样? 从 nil channel 接收数据会怎样? （阻塞无法被唤醒）
3. 发送到已关闭的 channel 会怎样?（死锁）
4. 从已关闭的 channel 接收数据会怎样?（返回类型零值）
5. channel是怎么引起 goroutine 泄露的? 或者说，goroutine 泄露有什么原因?（channel一直阻塞，无法被唤醒）
6. channel发送步骤，channel 接收步骤？
7. 为什么 channel发送指针数据会引起内存泄露?（只发送不接收，只接受不发生，一直阻塞）
8. 可能的代码题:
   用channel实现一个任务池
   用channel 来控制 goroutine 数量
   用channe[来实现生产者-消费者模型

#### 反射

runtime+unsafe实现

reflect.Value: 用于操作值，部分值是可以被反射修改的

reflect.Type: 用于操作类信息，类信息是只能读取

reflect.Type 可以通过 reflect.Value 得到，但是反过来则不行。
