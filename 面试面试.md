#### Docker

##### 1.说说常用的docker命令？

- docker pull、docker run、docker exec -it、docker commit、docker tag、dcoker push

##### 2.对docker的理解，什么是docker?

- 类似VM虚拟机一样的虚拟技术。但比虚拟机更轻量，docker利用linux提供的api实现进程隔离，资源限制，将应用程序及其依赖打包为容器迁移到安装了docker的环境中运行。一次构建，处处运行。

- docker有三部分组成：镜像（image）+容器（container）+仓库（repository）

  镜像是文件, 容器是镜像跑起来后的进程，可以把运行中的容器提交为镜像上传到远程仓库，别的服务器再从仓库拉取镜像构建容器。

##### 3.容器是啥？

- 容器其实是进程，容器中的进程被限制了对CPU内存等资源的访问，进程停止，容器退出

#####  4.Dockerfile中的命令COPY和ADD命令有什么区别？

- 都是拷贝文件/目录到容器里，区别是ADD遇到压缩格式会解压并复制



#### k8s

##### 1.怎么理解pod

- 容器组，k8s调度的基本单位，共享linux名字空间和文件系统卷，ip，端口空间的一组docker容器。pod内的容器可以使用localhost互相通讯。



#### go
##### 说说你对协程的理解？

- go官方在runtime包帮我们封装的轻量级线程，用go关键字创建，协程的切换由go自己维护，不会像系统线程一样陷入内核态，而且初始内存小，系统能轻松并发多个协程。

##### 协程的调度过程？

- gmp模型
- g是协程，记录一些执行栈，状态，任务函数。
- m是对物理线程的封装，g要调度到m上执行。
- p是一组g队列，p的数量决定go程序能并行执行的任务数，默认和cpu的核数相等。go早期在全局维护一组g队列，多个m从全局队列争抢g执行，并发争抢时要加锁，锁竞争太大，才引入一层p，每个m都要绑定1个p，从本地p队列获取g，找不到才找全局g队列，减少了全局队列的锁竞争。

##### GMP详细调度过程？

当我们执行`go func() {}...`

- 会尝试新建一个新G，为了复用曾经创建过的G，会先尝试从P本地队列拿空闲的g，拿不到再从全局任务队列迁移一批g到本地p，全局拿不到则会创建g加入当前p队列（proc.go/newproc方法）

- 当新创建的g加入p时，p满了(全是非空闲的g)，会取当前p本地队列前一半（避免后半部分G饥饿）g迁移到全局任务队列（proc.go/runqputslow方法）

- 然后为了充分发挥多核优势，会尝试唤醒空闲的p和空闲的m去取全局任务队列中的g执行（proc.go/wakep方法）

  尝试唤醒时，如果空闲p(全局有一个空闲p链表)不存在直接返回，存在，获取空闲M，空闲M不存在，新建M（proc.go/newm方法），MP绑定执行全局任务队列中的G（proc.go/wakep方法）

- 被唤醒后，进入工作状态的MP会从各种可能场所调度并执行G。一次调度流程（proc.go/schedule方法）

  p每这样调度61次会优先尝试从全局任务队列获取g，如果以上所有的方法都无法获取g，m会释放p进入休眠。

- 1. 先寻找本地队列，否
  2. 从全局任务队列获取，同时迁移一批g(避免频繁访问)到本地队列，否
  3. 从网络轮询器里拿就绪的G
  4. 都没有随机选择一个p窃取其二分之一后尾部的g(work-stealing)

##### GC

- 由go程序帮我们管理内存，让程序员只关注业务的开发。go采用三色标记法，即一开始所有的变量都标记为白色，从根节点出发，把可达变量标记为灰色，根节点就是全局变量，主协程变量，这些变量当前引用到的变量称为可达变量，再遍历标记为灰色的变量，找出他们的可达对象，经过变量的灰色对象标记为黑色，新的可达对象标记为灰色，重复这个过程，最后所有正在使用的变量都会标记为黑色，没用到的对象标记为白色，由gc回收。
- 三色标记法gc过程中需要暂停程序运行，效率很差，go1.8采用三色标记法+混合写屏障。混合写屏障就是在gc过程中把所有删除和添加的对象都置灰，1.8栈不启用混合写屏障，只是在gc开启时把所有可达对象标记为黑色，因为只有一轮所以不需要stw，新创建的对象置黑，添加和删除的对象置灰，堆空间则采用混合写屏障。

