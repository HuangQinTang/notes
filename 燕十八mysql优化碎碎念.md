#### 临时表(Using temporary)被创建的情况

- 如果group by 的列没有索引,必产生内部临时表

- 如果order by 与group by为不同列时,或多表联查时order by ,group by 包含的列不是第一张表的列,将会产生临时表
- distinct 与order by 一起使用可能会产生临时表
- union合并查询时会用到临时表

- 一些情况下限制了内存临时表的使用,而使用磁盘临时表:
  - (使用了内部临时表的前提下) 语句中存在BLOB或TEXT列
  - 在GROUP BY 或 DISTINCT子句中有大于512字节的string列
  - 在UNION或UNION ALL时,SELECT语句里有大于512字节的string列

#### 表的优化

- 表结构的拆分,如核心字段都用int,char,enum等定长结构
- 非核心字段,或用到text,超长的varchar,拆出来单放一张表
  -  定长与变长分离，如 id int, 占4个字节, char(4) 占4个字符长度,也是定长, time ，即每一单元值占的字节是固定的.核心且常用字段,宜建成定长,放在一张表.而varchar, text,blob,这种变长字段,适合单放一张表, 用主键与核心表关联起来.
  - 常用字段和不常用字段要分离.需要结合网站具体的业务来分析,分析字段的查询场景,查询频度低的字段,单拆出来.
  - 合理添加冗余字段.

#### 列的选择原则

- 字段类型优先级 整型 > date, time > enum, char>varchar > blob

> 整型: 定长,没有国家/地区之分,没有字符集的差异
>
> time定长,运算快,节省空间. 考虑时区,写sql时不方便 where > ‘2005-10-12’;
>
> enum: 能起来约束值的目的, 内部用整型来存储,但与char联查时,内部要经历串与值的转化
>
> Char 定长, 考虑字符集和(排序)校对集
>
> varchar, 不定长 要考虑字符集的转换与排序时的校对集,速度慢.
>
> text/Blob 无法使用内存临时表
