##### 1. 有哪些数据类型？

- 基本类型：整型，字符串，浮点型，布尔值
- 引用类型：切片，chan，map
- 其他类型：数组，结构体，函数，接口，指针

##### 2. 方法和函数的区别

- 方法有接收者，函数没有，编译器会默认把接收者传递給方法。

##### 3. Go方法值接收者和指针接收者的区别

- 如果方法的接收者是指针类型，无论调用者是对象还是指针对象，修改的都是对象本身(因为编辑器会帮我们把值类型隐式转换指针值类型)，会影响调用者。

- 如果方法的接收者是值类型，无论调用者是对象还是指针对象，修改的都是对象的拷贝，不会影响调用者。

- 两种情况值类型无法调用指针接收者

  - 用指针接收者实现接口时。

  - 值类型不能被寻址

    ```go
    package main
    
    import (
    	"fmt"
    )
    
    type field struct {
    	name string
    }
    
    func (p *field) pointerMethod() {
    	fmt.Println(p.name)
    }
    
    func (p field) valueMethod() {
    	fmt.Println(p.name)
    }
    
    func NewFiled() field {
    	return field{name: "right value struct"}
    }
    
    func main() {
    	NewFiled().valueMethod()
    	NewFiled().pointerMethod()
    }
    
    /**
    看下青藤木鸟的解释：
        看来编译器首先试着给 NewFiled() 返回的右值调用 pointer method，出错；然后试图给其插入取地址符，未果，就只能报错了。
        至于左值和右值的区别，大家感兴趣可以自行搜索一下。大致来说，最重要区别就是是否可以被寻址，可以被寻址的是左值，既可以出现在赋值号左边也可以出现在右边；不可以被寻址的即为右值，比如函数返回值、字面值、常量值等等，只能出现在赋值号右边。
    **/
    ```

##### 4. go函数返回局部变量的指针是否安全？

- 一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了“无所谓”的引用，程序会进入未知状态。
- 但这在Go中是安全的，Go编辑器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上，因为他们不在栈区，即使释放函数，其内容也不会受影响。

##### 5. Go函数参数传递到底是值传递还是引用传递？

- go语言中所有的传参都是值传递，。指针变量作为参数传递也是，相当于值拷贝，拷贝的是内存地址，但底层引用的还是同一块内存。

##### 6. Go内置函数make和new的区别？

- make和new是内置函数

- 变量初始化一般分为2步，变量声明+变量内存分配

- var关键字用来声明变量。make和new函数用来分配内存

- var声明值类型时，系统会默认分配内存空间，并赋予该类型的零值。var声明指针类型或引用类型时，系统不会分配内存，默认为nil。

- 区别：

  - make用来分配以及初始化slice、map、chan，编译器会将make转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。

  - new返回一个指向该类型内存地址(按类型分配长度)的指针，不关心类型内部构造和初始化方式。
  - 简单来说，new 只分配内存,make 用于初始化 slice、map 和 channel。

##### 7. 数组和切片的区别？

- 数组初始化必须指定长度，长度是固定的。切片长度不固定，可以追加元素。
- 函数传参不同。
  - 数组是值类型，一个数组赋予另一个数组是，会复制整个数组数据，深拷贝。函数体内对数组元素修改，不影响原数组。
  - 切片是引用类型，将一个切片赋予另一个切片时，传递的是一份浅宝贝，函数传参不会拷贝整个切片，只会复制len和cap，底层公用一个数组。不会占用额外的内存，函数体内对切片元素的修改，会影响底层数组内容。
- 计算数组长度方式不同
  - 数组需要遍历计算数组长度。时间复杂度O(n)
  - 切片底层包含Len字段，通过len()函数计算切片长度，时间复杂度O(1)

##### 8. Slice 的深拷贝和浅拷贝

- 深拷贝：拷贝的是数据本身，创造一个新对象，新对象与原对象不共享内存。新对象的修改不影响原对象。
- 浅拷贝：拷贝数据内存地址，只复制指向的对象的指针，此时新旧对象指向的内存地址是一样的。新对象修改原对象也会发生变化。

##### 9. Slice 的扩容机制

- 通常情况下
  - 如果新申请的容量比两倍原有容量大，那么扩容后为新申请的容量
  - 如果原切片长度小于1024，那么每次扩容为原来2倍
  - 如果原切片长度大于等于1024，那么每次扩容就反复增加25%
- 扩容机制很复杂，与CPU位数、元素大小、是否包含指针、追加个数等都有关系

##### 10. Slice 是线程安全的么？

- 如果不用append()对slice进行并发读写，他是线程安全的。append()触发扩容后会出现新旧指针指向的内存地址不一致，即使没触发扩容当多个协程同时对一个切片append()时，也容易造成数据不一致的情况。

  
