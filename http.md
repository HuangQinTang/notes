#### 浏览器发送http请求过程

![image-20220913234642391](C:\Users\Yeah\Desktop\note\notes\img\image-20220913234642391.png)

一、Redirect
判断是否需要跳转（浏览器有可能记录当前url已经永久跳转到新的url），以及跳转。
二、App cache
查询本地是有缓存（要请求的资源），没有缓存向实际服务器请求资源
三、DNS
即查找用于输入的域名对应的真实ip，通常先从本地host文件获取，要依次像更高级DNS服务器获取。拿到ip后，再通过一大丢乱七八糟的协议，经过各个路由，局域网最后找到目标服务器发送数据。
三、TCP
三次握手，，，四次挥手，，，
四、发送请求，，，接收响应。。



#### http协议历史

- 主要阶段：**http/1.1**之前、**http1.1**、**http/2.0**。
- 主要区别就是1.1前，连接不复用。1.1支持长连接可复用，同时可建立多个连接，但每个连接只能窜行发送请求。2.0每个连接可以同时并行发送请求，二进制传输，支持服务端主动推送。
- [http协议面试细节](https://www.bilibili.com/video/BV11G4y1Y717?spm_id_from=333.999.0.0&vd_source=7c0892485e4b2ae87d30238c61ca2c86)

##### http/0.9

- 只有GET命令
- 没有header等描述数据的信息
- 服务器发送完毕，就关闭TCP链接，只能html格式字符串，不能回应别的格式。

##### http/1.0

- 增加了很多命令，比如post，put等
- 增加status code 和 header
- 多字符集支持、多部份发送、权限、缓存等 

##### http/1.1

- 默认持久链接（1.1以前链接不复用，每个请求需要建立一个tcp链接，消耗资源），还可以同时建立多个连接。
- pipeline（可以在同一个链接里发送多个请求，但服务端需要按请求的顺序进行返回，即窜行处理，前一个请求会阻塞后一个请求）
- 增加host(可以在同一个物理机上建立多个web服务，通过host区分)和其他一些命令

##### http/2.0

- 所有数据以二进制进行传输（2.0之前通过字符串）
-  同一个连接里面发送多个请求不在需要按顺序来（可以并行处理）
- 头信息压缩以及推送（服务端主动）等提高效率的功能 



#### 三次握手

- 三次握手主要是规避因为网络问题导致的服务端开销问题。确认双方的发送和接收能力都正常。
- 如果只有两次握手就建立连接，可能存在以下情况
  - 比如客户端请求建立连接，服务端建立了，回应了一个数据包，该数据包客户端没有收到。客户端以为连接失败，再次重新请求建立连接，这次成功了。此时服务端认为存在两个连接，客户端一个，服务端第一次建立的连接白白等在那，浪费资源。
  - 又比如客户端请求建立连接，因为网络问题，数据包并没有送到服务器，超时再次重新请求建立连接，这次成功了。此时，客户端第一次发送的包送到，服务端又建立了连接，此时服务端存在2个连接，客户端1个。两边状态不同步。

#### 四次挥手

- [四次挥手大概过程](https://www.zhihu.com/question/263429870/answer/2641031131)

- [TCP四次挥手中间两次会合并成一次吗？](https://www.zhihu.com/question/477295175/answer/2062855797)

#### 跨域

- 跨域是浏览器的安全策略

- 可以通过服务端设置响应头解决

  ```shell
  #允许所有的域名跨域请求
  'Access-Control-Allow-Origin' = '*'
  #跨域时允许的请求头
  'Access-Control-Allow-Header' = ''
  #跨域时允许的方法
  'Access-Control-Allow-Methods' = 'POST,PUT,DElete'
  #预请求验证后，1000秒内无需重复预请求
  'Access-Control-Max-Age':'1000'
  ```

#### 缓存

- 服务端跨域在响应头设置参数，告知浏览器把资源缓存到本地。这些响应头只是约定，并不是强制生效的。

  ```shell
  #浏览器缓存20秒
  'Cache-Control':'max-age=20'
  ```

  因为浏览器缓存是根据url连接创建的，通常会静态资源文件名会带上一窜hash值作缓存，需要更新缓存时，重新生成一窜新的hash值，使浏览器缓存失效。

  ```shell
  #浏览器缓存20秒,但仍会像服务端发送请求，验证当前缓存是否失效
  'Cache-Control':'max-age=20, no-cache'
  
  #服务端可以设置以下两个头帮助判断缓存是否失效
  'Last-Modified':'123'		#响应资源最后修改时间
  'Etag':'777'				#响应资源唯一标识，可以通过资源进行hash计算得到
  #浏览器收到这两个响应头之后，下次请求会携带上以下2个请求头
  'If-Modified-Since':'123'
  'If-None-Match':'777'
  #服务端可以这2个判断，如果资源未过期可以设置http状态码为304(未修改)告诉浏览器资源未更新，不需要响应数据。此时浏览器将忽略服务端返回结果，直接从本地缓存读取数据。
  
  #代理服务器缓存，如果有使用一些代理服务器，比如用nginx设置了缓存，此时a浏览器创建的缓存，b浏览器也能使用，因为在代理端就建立了缓存。
  'Cache-Control':'max-age=20, s-maxage=50'
  
  #服务端设置以下响应头后，只有客户端发送的请求头值一样时才使用缓存。
  'Vary':'X-Test-Cache'
  #比如手机端，pc端可以这样，避免phone拿到pc端缓存
  'X-Test-Cache':'phone'
  'X-Test-Cache':'pc'
  ```

#### 长连接

- 这个直接百度，一般浏览器都会默认带上长连接的请求头。
- 谷歌浏览器一个域名，最多建立6个tcp连接，之后的请求会复用之前建立的连接，或者之前的连接关闭了，重新建立新的tcp连接发送请求。

#### 跳转

```shell
#http status 302  临时跳转
#http status 301  永久跳转（慎重，因为浏览器会记录跳转的目标，下次直接从缓存中取，不会再经过服务器，除非用户手动清楚浏览器缓存）
"Location":"目标url"
```

#### csp内容安全策略

- 服务端返回html文本时，可以通过添加响应头，限制html获取资源的方式。或者报告资源获取越权。

  ```shell
  #不允许使用内联脚本或样式，限制引入文件的方式只能通过http https
  #此时html内嵌的js代码在浏览器中将无法执行，只有通过http请求的资源文件能得到执行
  'Content-Security-Policy':'default-src http: https:'
  
  #允许加载指定域名下的文件资源，self表示本域名 
  'Content-Security-Policy': 'default-src \'self\' http://www.baidu.com/'
  
  #上面那种方式限制不了表单请求，限制表单提交可以加上
  'Content-Security-Policy': 'default-src \'self\' form-action \'self\''
  
  #当违反出现违反安全策略时，可以添加以下头，让浏览器发送请求给服务器进行汇报
  #本域名下的/report路由
  'Content-Security-Policy': 'default-src \'self\' report-uri /report'
  ```

  ```html
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' report-uri /report">
  ```

#### https

  ![image-20220914235323641](C:\Users\Yeah\AppData\Roaming\Typora\typora-user-images\image-20220914235323641.png)

  - 第一次握手客户端发送第一个随机数（本地也保存一份），还有客户端支持加密的套件。
  - 第二次握手，服务端把第一个随机数保存，生成第二个随机数，发送给客户端，并告诉客户端选择的加密方案，还有服务端的ca证书（第三方机构签名，里面包含公钥）。
  - 客户端收到服务端的证书，先验证有没有问题，没问题保存第二个随机数，生成第三个随机数(也叫预主密钥)，用收到的服务端的公钥加密第三个随机数发送给服务端，服务端可以用私钥解密，此时这第三个随机数就只有客户端服务端知道，别人不知道，这是第三次握手发生的。
  - 此时客户端，服务端都有，第一、第二、第三(预主密钥)个随机数，用第二次握手服务端选择的加密套件对这三个随机数加密，得到会话密钥。正式传输数据就用这个会话密钥进行加密，
  - 随机数传递采用非对称加密，数据传输时采用对称加密。

