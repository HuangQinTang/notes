### 第二章 快速开始

- Go 编译器不允许声明导入某个包却不使用。包名前下划线让编译器接受这类导入，并且 调用对应包内的所有代码文件里定义的 init 函数。
- 在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0;对于字符串类型， 零值是空字符串;对于布尔类型，零值是 false;对于指针，零值是 nil。对于引用类型来说， 所引用的底层数据结构会被初始化为对应的零值。但是被声明为其零值的引用类型的变量，会返 回 nil 作为其值。



### 第三章 包

- 给包及其目录命名 时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。

- 在 Go 语言里，命名为 main 的包具有特殊的含义。Go 语言的编译程序会试图把这种名字的 包编译为二进制可执行文件。所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。

- 编译器会使用 Go 环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。标准库中 的包会在安装 Go 的位置找到。Go 开发者创建的包会在 GOPATH 环境变量指定的目录里查找。 GOPATH 指定的这些目录就是开发者的个人工作空间。

-   ```go
  //检测代码语法错误，，不能查出运行中的空指针报错
  go vet main.go
  
  //格式化代码
  go fmt
  
  //查看文档 比如查看fmt包
  go doc fmt
  
  //---注释风格---按以下风格注释，能被doc查询到
  // Retrieve连接到配置库，收集各种链接设置、用户名和密码。这个函数在成功时 // 返回 config 结构，否则返回一个错误。
  func Retrieve() (config, error) {}
  ```

### 第四章 数组、切片、映射

#### 数组

- 数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。

- 由于内存连续，CPU 能把正在使用的数据缓存更久的时间。而且内存连续很容易计算索引，可以快速迭代数组里的所 有元素。数组的类型信息可以提供每次访问一个元素时需要在内存中移动的距离。既然数组的每 个元素类型相同，又是连续分配，就可以以固定速度索引数组中的任意数据，速度非常快。
- 根据内存和性能来看，在函数间传递数组是一个开销很大的操作。在函数之间传递变量时， 总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复 制，并传递给函数。（巨大无比的数组用指针传递，小数组选择值拷贝，分配到栈，通常栈运行的比堆块）

#### 切片

- 切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处

- 切片有 3 个字段的数据结构， 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长 到的元素个数（即容量）。

  ![image-20220608112906557](.\img\image-20220608112906557.png)

-  使用索引声明切片

  ```go
  // 创建字符串切片
  // 使用空字符串初始化第 100 个元素
  slice := []string{99: ""}
  ```

- nil切片&空切片

  ```go
  // 创建 nil 整型切片
  var slice []int
  if slice == nil {		//会打印
      fmt.Println("111111111")
  }
  
  // 创建空的整形切片
  slice2 := []int{}
  if slice2 == nil {		//不会打印
      fmt.Println("2222222")
  }
  ```

  nil切片，用于函数要求返回一个切片但是发生异常的时候，此时可以返回nil切片，数据结构

  ![image-20220608114821913](.\img\image-20220608114821913.png)

  空切片在底层数组包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用， 例如，数据库查询返回 0 个查询结果时，空切片数据结构

  ![image-20220608115430648](.\img\image-20220608115430648.png)

  

- 2个索引创建切片的情况，切片之所以被称为切片，是因为创建一个新的切片就是把底层数组切出一部分，

  ```go
  // 创建一个整型切片
  // 其长度和容量都是 5 个元素
  slice := []int{10, 20, 30, 40, 50}
  // 创建一个新切片
  // 其长度为 2 个元素，容量为 4 个元素
  newSlice := slice[1:3]
  ```
  
  ![image-20220608141454145](.\img\image-20220608141454145.png)
  
  它们共享同一段底层数组，如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到，但通过不同的切片会看到底层数组的不同部分。
  
  如何计算新切片的长度和容量?
  
  对底层数组容量是 k 的切片 slice[i:j] 来说 
  
  长度: j - i  
  
  容量: k - i  
  
  对 newSlice 应用这个公式就能得到如图所示的数字
  
- 扩容机制，如果切片的底层数组没有足够的可用容量，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值。

  [Go append 扩容机制](https://segmentfault.com/a/1190000040413412)
  
  - 扩容机制很复杂，与**与CPU位数、元素大小、是否包含指针、追加个数**等都有关系。
  - 通常需要的容量 `cap` 超过原切片容量的两倍 `doublecap`，会直接使用需要的容量作为新容量`newcap`。否则，当原切片长度小于1024时，新切片的容量会直接翻倍。而当原切片的容量大于等于1024时，会反复地增加25%，直到新容量超过所需要的容量。
  - 随着语言的演化，这种增长算法可能会有所改变。
  
- 使用 3 个索引创建切片的情况

  ```go
  // 将第三个元素切片，并限制容量
  // 其长度为 1 个元素，容量为 2 个元素
  slice := source[2:3:4]
  ```

  ![image-20220608144824268](.\img\image-20220608144824268.png)

  - 长度和容量如何计算？

    对于 slice[i:j:k] 或 [2:3:4] 

    长度: j – i 或 3 - 2 = 1 

    容量: k – i 或 4 - 2 = 2

  - 设置容量大于已有容量会报语言运行时错误

    如 `slice := source[2:3:6]`报错`panic: runtime error: slice bounds out of range`

- 扩容后的切片不会引用原数组

    如果基于一个切片创建另一个切片时，**设置长度和容量一样**，如：
    
    ```go
    // 创建字符串切片
    // 其长度和容量都是 5 个元素
    source := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}
    // 对第三个元素做切片，并限制容量
    // 其长度和容量都是 1 个元素
    slice := source[2:3:3]
    // 向 slice 追加新字符串
    slice = append(slice, "Kiwi")
    ```
    
    append后的slice会触发扩容机制，新创建底层数组，并拷贝引用原数组值，此时新的到的slice拥有自己的底层数组，不会影响原底层数组。

- range 提供了每个元素的副本

  ```go
  // 创建一个整型切片
  // 其长度和容量都是 4 个元素
  slice := []int{10, 20, 30, 40}
  // 迭代每个元素，并显示值和地址
  for index, value := range slice { 
  	fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n",
                 value, &value, &slice[index])
  }
  
  //运行结果
  Output: 
  Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100
  Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104
  Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108
  Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C
  ```

  value的地址总是相同的，因为迭代返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以 value 的地址总 是相同的。要想获取每个元素的地址，可以使用切片变量和索引值。指针切片(一个切片里充满了指针)可以不需要。

- 多维切片结构

  ![image-20220608152311409](.\img\image-20220608152311409.png)
